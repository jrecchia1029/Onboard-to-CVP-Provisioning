from cvprac.cvp_client import CvpClient
from cvprac.cvp_client_errors import CvpApiError
#Disables no certificate CVP warning
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import json, re, csv
import argparse
from getpass import getpass

def updateInCVP(cvp, name, config, serial_number, apply=True):
    '''
    Args:
        name (str) -> name of the configlet
        config (str) -> content of configlet
        serial_number (str) -> device serial number
    Returns list of taskIds if any [1, 21]
    '''
    #Attempt to get config
    try:
        configlet_exists = cvp.api.get_configlet_by_name(name)
    except:
        # print ("Configlet {} doesn't exist".format(name))
        configlet_exists = None
    #get device information from CVP
    device_dict = cvp.api.get_device_by_serial_number(serial_number)

    #initialize tasks variable
    task_ids = []
    tasks = None
    
    #Configlet does not exist
    if configlet_exists is None:
        #add new configlet to CVP
        configlet = cvp.api.add_configlet(name, config)
        # print ("Added Configlet {} to CVP".format(name))
        #get newly created configlet
        new_configlet = cvp.api.get_configlet_by_name(name)

        if apply==True:
            #Create list of configlets to apply 
            configlets_to_apply = []
            #Add configlet to list of configlets to apply
            configlets_to_apply.append(new_configlet)

            #apply configlet to device
            tasks = cvp.api.apply_configlets_to_device("Generated by deployment script", device_dict,  configlets_to_apply)

    else:
        #configlet already exists

        #check if config is in sync
        # if checkIfDeviceInSync(device_dict) != True:
        #     #If device is not in sync return None
        #     return None

        #update existing configlet
        key = configlet_exists["key"]
        tasks = cvp.api.update_configlet(config, key, name, wait_task_ids=True)
        # print ("Modified Configlet {} in CVP".format(name))

        if apply == True:

            try:
                if "taskIds" in list(tasks):
                    # print "Returning tasks for configlet {}".format(name)
                    task_ids = tasks["taskIds"]
            except:
                pass

            updated_configlet = cvp.api.get_configlet_by_name(name)
            configlets_already_applied = cvp.api.get_configlets_by_netelement_id(device_dict["key"])["configletList"]
            names_of_configlets_already_applied = []
            for configlet in configlets_already_applied:
                names_of_configlets_already_applied.append(configlet["name"])

            if updated_configlet["name"] not in names_of_configlets_already_applied:
                # print "Configlet {} is not applied".format(updated_configlet["name"])
                # print "Applying {} to {}".format(updated_configlet["name"], device_dict["hostname"])
                tasks = cvp.api.apply_configlets_to_device("Generated by deployment script", device_dict,  [updated_configlet])
                # print ("Reapplied configlet to device")

    # return tasks
    if len(task_ids) > 0:
        try:
            tasks = tasks["data"]
            if "taskIds" in list(tasks):
                # print "Returning tasks for configlet {}".format(name)
                for task in tasks["taskIds"]:
                    if task not in task_ids:
                        task_ids.append(task)
                # print ("task_ids:", task_ids)
                return task_ids
            else:
                # print "No tasks to return for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return task_ids
        except:
            # print ("task_ids:", task_ids)
            return task_ids
    else:
        try:
            tasks = tasks["data"]
            if "taskIds" in list(tasks):
                # print "Returning tasks for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return tasks["taskIds"]
            else:
                # print "No tasks to return for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return []
        except:
            return []

def deploy_device_with_no_configlets(cvp, device_dict, target_container, image_bundle, include_container_configlets=False):
    '''
        Creates a static configlet of the reconcile config produced as if no configlets are applied to the device
        Then deploys device into proper container based off of first three characters of device hostname and applies previously generated configlet
    '''
    configlets_to_generate_reconcile = []
    configlets_to_apply = []
    if device_dict["streamingStatus"] == "inactive":
        print("{} - Device is not streaming data to CVP".format(device_dict["hostname"]))
        return
    #get device information from CVP
    print("{} - Getting device information...".format(device_dict["hostname"]))
    # print "Device"
    # print json.dumps(device_dict)
    # print "\n\n"
    device_id = device_dict["systemMacAddress"]
    
    # print "Configlets"
    # print json.dumps(configlets)
    # print "\n\n"

    print("{} - Got device information".format(device_dict["hostname"]))

    #keys of configlets we'll pretend are applied to a device when we generate a reconcile config
    if include_container_configlets == True:
        container_configlet_keys = [ configlet["key"] for configlet in cvp.api.get_configlets_inherited_from_containers(target_container) ]
    else:
        container_configlet_keys = []

    configlets_to_generate_reconcile = container_configlet_keys

    print("configlets_to_generate_reconcile: {}".format(configlets_to_generate_reconcile))

    #Generate consolidated configlet
    print ("{} - Generating configlet configuration...".format(device_dict["hostname"]))
    validate_response = cvp.api.validate_configlets_for_device(device_id, configlets_to_generate_reconcile,
                                       page_type='validate')

    if "runningConfig" in validate_response.keys():
        config = []
        for i, line in enumerate(validate_response["runningConfig"]):
            if "vrf" in line["command"]:
                print(line)

            if include_container_configlets == True:
                if line["command"] == "!":
                    config.append(line["command"])
                elif line["code"] == "RED":
                    config.append(line["command"])
                elif re.match(r'interface (Ethernet|Management).+', line["command"]) is not None:
                    config.append(line["command"])
                else:
                    continue
            else:
                config.append(line["command"])
        
        # Parse out duplicate '!'s
        parsed_config = []
        for i, line in enumerate(config):
            if i != 0:
                if not(line == "!" and config[i-1] == "!"):
                    parsed_config.append(line)
        config = parsed_config

        config = "\n".join(config)
    else:
        print("{} - No reconcile configlet to generate.".format(device_dict["hostname"]))
        return

    #Create and apply consolidated configlet
    configlet_name = device_dict["hostname"]

    #Create New Configlet
    print ("{} - Updating/Creating configlet...".format(device_dict["hostname"]))
    tasks =  updateInCVP(cvp, configlet_name, config, device_dict["serialNumber"], apply=False)
    print ("{} - Updated/Created configlet".format(device_dict["hostname"]))

    try:
        configlet_to_apply = cvp.api.get_configlet_by_name(configlet_name)
    except CvpApiError as e:
        configlet_to_apply = None

    if configlet_to_apply is not None:
        configlets_to_apply.append(configlet_to_apply)
    else:
        print("{} - Could not find configlet named {}".format(configlet_name, device_dict["hostname"]))
        return

    if device_dict["parentContainerKey"] != "undefined_container":
        #Get already applied configlets at device level
        device_level_configlets = cvp.api.get_configlets_by_netelement_id(device_id)["configletList"]
        cvp.api.remove_configlets_from_device("Removed by script", device_dict, device_level_configlets)
        cvp.api.apply_configlets_to_device("Added by script", device_dict, configlets_to_apply)
    else:
        if target_container != "" and cvp.api.get_container_by_name(target_container) is None:
            print("{} - Could not find destination container for {}".format(device_dict["hostname"], device_dict["hostname"]))
            return
        
        if image_bundle != "" and cvp.api.get_image_bundle_by_name(image_bundle) is None:
            print("{} - Could not find image bundle for {}".format(device_dict["hostname"], device_dict["hostname"]))
            return
        cvp.api.deploy_device(device_dict, target_container, configlets=configlets_to_apply, image=image_bundle)
    return

def parse_switch_info_file(switch_info_file):
    switches = {} #Using serial number as key
    with open(switch_info_file) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        line_count = 0
        for row in csv_reader:
            if line_count == 0:
                attributes = [attr.strip() for attr in row ] 
                line_count += 1
            else:
                switch_info = {}
                for col in range(len(attributes)):
                    switch_info[attributes[col]] = row[col]
                switches[switch_info["Hostname"]] = {
                    "Target Container": switch_info["Target Container"].strip(),
                    "Image Bundle": switch_info["Image Bundle"].strip()
                }
                line_count += 1
    return switches

def parseArgs():
    parser = argparse.ArgumentParser(
        description='Provisions devices in CVP')

    parser.add_argument('-u', '--user', help="Username for CVP user")
    parser.add_argument('-p', '--password', default=None, help="Password for CVP user")
    parser.add_argument('-i', '--inventory', help="path to switch management details file")
    parser.add_argument('-host', '--cvp', help="CVP node IP Addresses separated by commas")

    args = parser.parse_args()

    return args

def main():
    args = parseArgs()
    username = args.user
    password = args.password
    if password is None:
        print("Please provide a password for the user {}".format(username))
        password = getpass("Password:")
    cvp_addresses = [ address.strip() for address in  args.cvp.split(",") ]
    inventory_file = args.inventory
    switch_info_dict = parse_switch_info_file(inventory_file)
    cvp = CvpClient()
    cvp.connect(cvp_addresses, username, password)
    inventory = cvp.api.get_inventory()
    for switch in inventory:
        #Check to see if switch in spreadsheet and get VRF 
        try:
            switch_details = switch_info_dict[switch["hostname"]]
        except KeyError:
            print("Could not find {}'s serial number in spreadsheet".format(switch["hostname"]))
            continue
        deploy_device_with_no_configlets(cvp, switch, switch_details["Target Container"], switch_details["Image Bundle"], include_container_configlets=True)

if __name__ == "__main__":
    main()